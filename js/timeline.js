// Timeline functionality - simplified for Apps Script compatibility
function initializeTimeline() {
  console.log('üîß Timeline initialization started...');
  
  const timelineSection = document.querySelector('.timeline-section');
  if (!timelineSection) {
    console.error('‚ùå Timeline section not found!');
    return;
  }

  // Get timeline elements (generated by Apps Script)
  let timelineProgress = document.querySelector('.timeline-progress');
  let timelineItems = document.querySelectorAll('.timeline-item');
  let timelineMarkers = document.querySelectorAll('.timeline-marker');

  if (!timelineProgress || !timelineItems.length || !timelineMarkers.length) {
    console.warn('‚ö†Ô∏è Timeline elements not found - may not be generated yet');
    return;
  }

  console.log(`‚úÖ Found ${timelineItems.length} timeline items and ${timelineMarkers.length} markers`);

  // Update timeline based on scroll position
  function updateTimeline() {
    const scrollTop = window.pageYOffset;
    const windowHeight = window.innerHeight;
    
    // Calculate progress through the entire timeline section
    const sectionRect = timelineSection.getBoundingClientRect();
    const sectionTop = scrollTop + sectionRect.top;
    const sectionHeight = sectionRect.height;
    
    // Progress calculation based on how far we've scrolled through the timeline section
    let progress = 0;
    if (scrollTop > sectionTop - windowHeight) {
      progress = Math.min((scrollTop - sectionTop + windowHeight) / sectionHeight, 1);
    }
    
    // Update progress bar height
    const progressPercent = Math.max(0, Math.min(progress * 100, 100));
    timelineProgress.style.height = `${progressPercent}%`;

    // Find which timeline item should be active based on viewport center
    let activeIndex = 0;
    let bestScore = -Infinity;

    timelineItems.forEach((item, index) => {
      const itemRect = item.getBoundingClientRect();
      const itemTop = itemRect.top;
      const itemBottom = itemRect.bottom;
      const itemCenter = itemTop + itemRect.height / 2;
      const windowCenter = windowHeight / 2;
      
      // Item is visible in viewport
      if (itemBottom > 0 && itemTop < windowHeight) {
        // Calculate how close the item center is to window center
        const distanceFromCenter = Math.abs(windowCenter - itemCenter);
        
        // Prefer items that are more centered and more visible
        const visibilityScore = Math.min(
          itemBottom - Math.max(itemTop, 0),
          windowHeight
        ) / windowHeight;
        
        const centerScore = 1 - (distanceFromCenter / windowHeight);
        const totalScore = visibilityScore * 0.7 + centerScore * 0.3;
        
        if (totalScore > bestScore) {
          bestScore = totalScore;
          activeIndex = index;
        }
      }
    });

    // Update active states
    timelineItems.forEach((item, index) => {
      if (index === activeIndex) {
        item.classList.add('active');
      } else {
        item.classList.remove('active');
      }
    });

    timelineMarkers.forEach((marker, index) => {
      if (index === activeIndex) {
        marker.classList.add('active');
      } else {
        marker.classList.remove('active');
      }
    });
  }

  // Handle marker clicks - scroll to corresponding timeline item
  function setupMarkerClicks() {
    timelineMarkers.forEach((marker, index) => {
      marker.addEventListener('click', () => {
        const targetItem = timelineItems[index];
        if (targetItem) {
          const itemRect = targetItem.getBoundingClientRect();
          const offsetTop = window.pageYOffset + itemRect.top - (window.innerHeight / 2) + (itemRect.height / 2);
          
          window.scrollTo({
            top: Math.max(0, offsetTop),
            behavior: 'smooth'
          });
        }
      });
    });
  }

  // Use throttled scroll listening for better performance
  let ticking = false;
  
  function onScroll() {
    if (!ticking) {
      requestAnimationFrame(() => {
        updateTimeline();
        ticking = false;
      });
      ticking = true;
    }
  }

  // Setup all interactivity
  function setupInteractivity() {
    console.log('‚öôÔ∏è Setting up timeline interactivity...');
    
    // Setup marker clicks
    setupMarkerClicks();
    
    // Listen for scroll events
    window.addEventListener('scroll', onScroll, { passive: true });

    // Initial update
    updateTimeline();

    // Handle window resize
    window.addEventListener('resize', () => {
      setTimeout(updateTimeline, 100);
    });
    
    console.log('‚úÖ Timeline interactivity setup complete');
  }

  // Start setup
  setupInteractivity();
}

// Add this to your timeline.js file

/**
 * Dynamically position the fixed sidebar relative to the centered timeline
 */
function positionFixedSidebar() {
  const sidebar = document.querySelector('.timeline-sidebar');
  const container = document.querySelector('.timeline-container');
  
  if (!sidebar || !container) return;
  
  // Only apply dynamic positioning on larger screens
  if (window.innerWidth < 768) {
    sidebar.style.left = 'auto';
    return;
  }
  
  // Get the container's position
  const containerRect = container.getBoundingClientRect();
  const containerLeft = containerRect.left + window.scrollX;
  
  // Position sidebar to the left of the container with some offset
  const sidebarLeft = Math.max(16, containerLeft - 220); // 220px = sidebar width + margin
  
  sidebar.style.left = `${sidebarLeft}px`;
}

/**
 * Enhanced timeline initialization with dynamic sidebar positioning
 */
function initializeTimelineWithDynamicSidebar() {
  console.log('üîß Timeline initialization with dynamic sidebar started...');
  
  const timelineSection = document.querySelector('.timeline-section');
  if (!timelineSection) {
    console.error('‚ùå Timeline section not found!');
    return;
  }

  // Position sidebar initially
  positionFixedSidebar();

  // Get timeline elements
  let timelineProgress = document.querySelector('.timeline-progress');
  let timelineItems = document.querySelectorAll('.timeline-item');
  let timelineMarkers = document.querySelectorAll('.timeline-marker');

  if (!timelineProgress || !timelineItems.length || !timelineMarkers.length) {
    console.warn('‚ö†Ô∏è Timeline elements not found - may not be generated yet');
    return;
  }

  console.log(`‚úÖ Found ${timelineItems.length} timeline items and ${timelineMarkers.length} markers`);

  // Update timeline based on scroll position
  function updateTimeline() {
    const scrollTop = window.pageYOffset;
    const windowHeight = window.innerHeight;
    
    const sectionRect = timelineSection.getBoundingClientRect();
    const sectionTop = scrollTop + sectionRect.top;
    const sectionHeight = sectionRect.height;
    
    let progress = 0;
    if (scrollTop > sectionTop - windowHeight) {
      progress = Math.min((scrollTop - sectionTop + windowHeight) / sectionHeight, 1);
    }
    
    const progressPercent = Math.max(0, Math.min(progress * 100, 100));
    timelineProgress.style.height = `${progressPercent}%`;

    // Find active timeline item
    let activeIndex = 0;
    let bestScore = -Infinity;

    timelineItems.forEach((item, index) => {
      const itemRect = item.getBoundingClientRect();
      const itemTop = itemRect.top;
      const itemBottom = itemRect.bottom;
      const itemCenter = itemTop + itemRect.height / 2;
      const windowCenter = windowHeight / 2;
      
      if (itemBottom > 0 && itemTop < windowHeight) {
        const distanceFromCenter = Math.abs(windowCenter - itemCenter);
        
        const visibilityScore = Math.min(
          itemBottom - Math.max(itemTop, 0),
          windowHeight
        ) / windowHeight;
        
        const centerScore = 1 - (distanceFromCenter / windowHeight);
        const totalScore = visibilityScore * 0.7 + centerScore * 0.3;
        
        if (totalScore > bestScore) {
          bestScore = totalScore;
          activeIndex = index;
        }
      }
    });

    // Update active states
    timelineItems.forEach((item, index) => {
      if (index === activeIndex) {
        item.classList.add('active');
      } else {
        item.classList.remove('active');
      }
    });

    timelineMarkers.forEach((marker, index) => {
      if (index === activeIndex) {
        marker.classList.add('active');
      } else {
        marker.classList.remove('active');
      }
    });
  }

  // Handle marker clicks
  function setupMarkerClicks() {
    timelineMarkers.forEach((marker, index) => {
      marker.addEventListener('click', () => {
        const targetItem = timelineItems[index];
        if (targetItem) {
          const itemRect = targetItem.getBoundingClientRect();
          const offsetTop = window.pageYOffset + itemRect.top - (window.innerHeight / 2) + (itemRect.height / 2);
          
          window.scrollTo({
            top: Math.max(0, offsetTop),
            behavior: 'smooth'
          });
        }
      });
    });
  }

  // Throttled scroll and resize handlers
  let ticking = false;
  
  function onScroll() {
    if (!ticking) {
      requestAnimationFrame(() => {
        updateTimeline();
        ticking = false;
      });
      ticking = true;
    }
  }

  function onResize() {
    positionFixedSidebar();
    setTimeout(updateTimeline, 100);
  }

  // Setup all interactivity
  function setupInteractivity() {
    console.log('‚öôÔ∏è Setting up timeline interactivity with dynamic sidebar...');
    
    setupMarkerClicks();
    
    window.addEventListener('scroll', onScroll, { passive: true });
    window.addEventListener('resize', onResize);

    // Initial update
    updateTimeline();
    
    console.log('‚úÖ Timeline interactivity with dynamic sidebar setup complete');
  }

  setupInteractivity();
}

// Simple CSS-only approach for the sidebar
function setupSimpleFixedSidebar() {
  const sidebar = document.querySelector('.timeline-sidebar');
  if (!sidebar) return;
  
  // Apply fixed positioning with calculated left position
  sidebar.style.position = 'fixed';
  sidebar.style.top = '50%';
  sidebar.style.transform = 'translateY(-50%)';
  sidebar.style.zIndex = '100';
  
  // Calculate left position based on screen size
  function updateSidebarPosition() {
    const screenWidth = window.innerWidth;
    
    if (screenWidth < 768) {
      // Mobile - hide or position differently
      sidebar.style.display = 'none';
    } else if (screenWidth < 1300) {
      // Medium screens - fixed left position
      sidebar.style.left = '2rem';
      sidebar.style.display = 'block';
    } else {
      // Large screens - position relative to center
      const centerOffset = (screenWidth - 1200) / 2; // 1200px = timeline max-width
      sidebar.style.left = `${Math.max(16, centerOffset + 16)}px`;
      sidebar.style.display = 'block';
    }
  }
  
  updateSidebarPosition();
  window.addEventListener('resize', updateSidebarPosition);
}

// Export functions
window.initializeTimelineWithDynamicSidebar = initializeTimelineWithDynamicSidebar;
window.setupSimpleFixedSidebar = setupSimpleFixedSidebar;

// Call the appropriate function based on your preference
// Option 1: Full dynamic positioning
// initializeTimelineWithDynamicSidebar();

// Option 2: Simple CSS-based positioning
// setupSimpleFixedSidebar();

// Export for use in main.js
window.initializeTimeline = initializeTimeline;